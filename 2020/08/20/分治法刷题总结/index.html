<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>分治法刷题总结 | 东北石油大学智能技术与自然语言处理实验室</title><meta name="description" content="分治法刷题总结"><meta name="keywords" content="数据结构,leetcode,分治法,递归"><meta name="author" content="东北石油大学智能技术与自然语言处理实验室"><meta name="copyright" content="东北石油大学智能技术与自然语言处理实验室"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/ava.jpg"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="分治法刷题总结"><meta name="twitter:description" content="分治法刷题总结"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/zhengguanyu/zhengguanyu.github.io@2.0/img/Second.jpg"><meta property="og:type" content="article"><meta property="og:title" content="分治法刷题总结"><meta property="og:url" content="https://nlplab406.github.io/2020/08/20/%E5%88%86%E6%B2%BB%E6%B3%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"><meta property="og:site_name" content="东北石油大学智能技术与自然语言处理实验室"><meta property="og:description" content="分治法刷题总结"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhengguanyu/zhengguanyu.github.io@2.0/img/Second.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://nlplab406.github.io/2020/08/20/%E5%88%86%E6%B2%BB%E6%B3%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"><link rel="next" title="阅读文章——基于 CART 决策树的计算机网络课程学生成绩分析" href="https://nlplab406.github.io/2020/08/16/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">东北石油大学智能技术与自然语言处理实验室</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/ava.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">26</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">31</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#写在前面"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">写在前面</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#53-最大自序和"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">53.最大自序和</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目描述"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#分治法"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">分治法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目代码"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">题目代码</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#169-多数元素"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">169.多数元素</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目描述-1"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#暴力法"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">暴力法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目代码-1"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">题目代码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#分治法-1"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">分治法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#初始代码"><span class="toc_mobile_items-number">3.5.</span> <span class="toc_mobile_items-text">初始代码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#改进代码"><span class="toc_mobile_items-number">3.6.</span> <span class="toc_mobile_items-text">改进代码</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#50-Pow-x-n"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">50.Pow(x,n)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目描述-2"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">题目描述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目理解"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">题目理解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#题目代码-2"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">题目代码</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#写在前面"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-最大自序和"><span class="toc-number">2.</span> <span class="toc-text">53.最大自序和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述"><span class="toc-number">2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分治法"><span class="toc-number">2.2.</span> <span class="toc-text">分治法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题目代码"><span class="toc-number">2.3.</span> <span class="toc-text">题目代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#169-多数元素"><span class="toc-number">3.</span> <span class="toc-text">169.多数元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-1"><span class="toc-number">3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#暴力法"><span class="toc-number">3.2.</span> <span class="toc-text">暴力法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题目代码-1"><span class="toc-number">3.3.</span> <span class="toc-text">题目代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分治法-1"><span class="toc-number">3.4.</span> <span class="toc-text">分治法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始代码"><span class="toc-number">3.5.</span> <span class="toc-text">初始代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改进代码"><span class="toc-number">3.6.</span> <span class="toc-text">改进代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-Pow-x-n"><span class="toc-number">4.</span> <span class="toc-text">50.Pow(x,n)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-2"><span class="toc-number">4.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题目理解"><span class="toc-number">4.2.</span> <span class="toc-text">题目理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题目代码-2"><span class="toc-number">4.3.</span> <span class="toc-text">题目代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/zhengguanyu/zhengguanyu.github.io@2.0/img/Second.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">分治法刷题总结</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-08-20<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-08-20</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%83%91%E5%86%A0%E5%BD%A7/">郑冠彧</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%83%91%E5%86%A0%E5%BD%A7/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">3k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 11 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;&emsp;分治法简单理解就是分而治之，将一个复杂的问题通过一定的方式分解成若干个类似的小问题。其实，从字里行间便能体会到递归的含义。没错，本质上来说，我们还是通过分治法求解去体会递归的魅力。至少接下来的三道题，我是这样做的～～<br>&emsp;&emsp;前排提醒，一开始遇到递归的问题，私以为不要过于追求细节，这样很容易迷失在递归过程中，造成自我怀疑。有一定基础的可以自己画棵树体会过程，或者直接翻题解找到类似的图也可。重要的是体会思想，剩下的就是重复练习。</p>
<p><br></p>
<h2 id="53-最大自序和"><a href="#53-最大自序和" class="headerlink" title="53.最大自序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53.最大自序和</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>&emsp;&emsp;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>&emsp;&emsp;示例:</p>
<blockquote>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<p>&emsp;&emsp;进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>&emsp;&emsp; 暴力法比较esay，不再赘述，双循环即可。<br>&emsp;&emsp; 题目要求我们求<strong>连续数组的最大和</strong>，并尝试采用分治法。为了便于分解，我们可以递归地从数组中间将其分成左右两子区间。我们现在就将目光集中到如何求当前区间的最大和？三种情况奉上～</p>
<blockquote>
<ol>
<li>左区间最大和</li>
<li>右区间最大和</li>
<li>跨越中点的区间最大和</li>
</ol>
</blockquote>
<p>&emsp;&emsp; 注意：这里第三种情况是容易被忽略的，当然也是比较难实现的一点，不妨用二叉树的递归模型来理解这一过程。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		PostOrder(T-&gt;lchild);</span><br><span class="line">		PostOrder(T-&gt;rchild);</span><br><span class="line">		visit(T);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>&emsp;&emsp; 这是后序遍历的递归套路，简单理解就是左右根，我们可以将重点放在对根节点的操作上，而左右交给递归过程。我们将其类比成本题的分治法：<strong>左右递归子树</strong>就是求左右区间的最大连续和，而<strong>根节点操作</strong>就是求中间衔接段的最大和并比较三者最大和。<br>&emsp;&emsp; 还有一点，当我们发现题目所给的函数的参数似乎不够用时，我们可以添加辅助函数<code>helper</code>。比如本题，显然我们在递归过程需要区间的左右端点，而<code>maxSubArray</code>的参数只有一个容器<code>nums</code>，这时候我们可以添加辅助函数<code>helper(vector&lt;int&gt;&amp; nums, int l, int r)</code>即可。</p>
<h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)                    <span class="comment">//判空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)                               <span class="comment">//递归出口 -&gt; 左端点大于右端点</span></span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;                 <span class="comment">//位运算 -&gt; 求数组中点</span></span><br><span class="line">        <span class="keyword">int</span> left = helper(nums, l, mid - <span class="number">1</span>);    <span class="comment">//左区间最大和</span></span><br><span class="line">        <span class="keyword">int</span> right = helper(nums, mid + <span class="number">1</span>, r);   <span class="comment">//右区间最大和</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//中间衔接段最大和（越过中点）</span></span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>, sum = <span class="number">0</span>; <span class="comment">//由中点向左发散最大值，由中点向右发散最大值，当前区间和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= l; i--)&#123;      <span class="comment">//求由中点向左发散最大值</span></span><br><span class="line">            sum += nums[i];</span><br><span class="line">            leftMax = max(leftMax, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;                                <span class="comment">//重新置0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++)&#123;      <span class="comment">//求由中点向右发散最大值</span></span><br><span class="line">            sum += nums[i];</span><br><span class="line">            rightMax = max(rightMax, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左区间最大和，右区间最大和，中间衔接段最大和，三者取最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(max(left, right), leftMax + rightMax + nums[mid]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><br></p>
<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169.多数元素</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>&emsp;&emsp; 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>&emsp;&emsp; 你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<blockquote>
<p>示例 1:<br>输入: [3,2,3]<br>输出: 3</p>
<p>示例 2:<br>输入: [2,2,1,1,1,2,2]<br>输出: 2</p>
</blockquote>
<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>&emsp;&emsp; 暴力解千愁，看见题目要求收集数组元素出现次数就应当想到空间换时间，即采用哈希表<code>unordered_map</code>。</p>
<h3 id="题目代码-1"><a href="#题目代码-1" class="headerlink" title="题目代码"></a>题目代码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; record;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">            record[num]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = nums.size() / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> rec : record)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rec.second &gt; len)&#123;</span><br><span class="line">                result = rec.first;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h3 id="分治法-1"><a href="#分治法-1" class="headerlink" title="分治法"></a>分治法</h3><p>&emsp;&emsp; 这次用分治法的思想非常巧妙，只机械地记忆模版（取数组中间位置）可能很难想到这样做的理由。那么为什么还是要去中间呢？本题要求我们求<strong>多数元素</strong>——出现次数大于<code>⌊ n/2 ⌋</code>的数。<strong>这个前提条件很重要，没有了它，后面的分治法将无从下手</strong>。<br>&emsp;&emsp; 好了，我们是否可以这样想，如果我们将数组一分为二，那么这个<code>多数元素</code>至少是一个部分的<code>多数元素</code>。具体的反证法见<a href="https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/" target="_blank" rel="noopener">leetcode官方题解</a>，私以为这更想是一个脑筋急转弯～所以现在知道为什么<code>⌊ n/2 ⌋</code>是如此的重要吧！因为没有这个“超过半数”，我们就无法反证刚才的猜想的正确性，没有这个猜想，我们就无法“堂而皇之”的取中间位置一分为二。<br>&emsp;&emsp; 剩下的工作就又回到了类似于二叉树后序递归模型中来，当然这次我们需要添加一个“工具人”函数<code>count</code>，让它帮我们计算每一区间内的<code>多数元素</code>。这样我们就可以将目光集中到对“根节点”的操作，也就是比较两个区间的<code>多数元素</code>。如果两区间<code>多数元素</code>相同，那么<code>return</code>这个多数元素；如果两区间<code>多数元素</code>不相同，那么需要比较这两个<code>多数元素</code>在合并的整个区间里出现的次数来决定<code>return</code>哪个值。</p>
<h3 id="初始代码"><a href="#初始代码" class="headerlink" title="初始代码"></a>初始代码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)                                <span class="comment">//递归出口，区间内仅有一个元素</span></span><br><span class="line">            <span class="keyword">return</span> nums[l];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (r - l) / <span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">int</span> leftMax = helper(nums, l, mid);       <span class="comment">//左区间多数元素</span></span><br><span class="line">        <span class="keyword">int</span> rightMax = helper(nums, mid + <span class="number">1</span>, r);  <span class="comment">//右区间多数元素</span></span><br><span class="line">        <span class="keyword">if</span>(leftMax == rightMax)                   <span class="comment">//左右区间多数元素相同</span></span><br><span class="line">            <span class="keyword">return</span> leftMax;</span><br><span class="line">        <span class="comment">//左右区间多数元素不同，比较在合并区间的次数</span></span><br><span class="line">        <span class="keyword">int</span> leftCount = count(nums, leftMax);</span><br><span class="line">        <span class="keyword">int</span> rightCount = count(nums, rightMax);</span><br><span class="line">        <span class="keyword">return</span> leftCount &gt; rightCount ? leftMax : rightMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">            <span class="keyword">if</span>(num == target)</span><br><span class="line">                c++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>&emsp;&emsp;<strong>注</strong>：这个c++版本会在倒数第二个测试用例栽跟头，不过思路是正确的。<br><a href="https://img-blog.csdnimg.cn/20200820205216510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwNzcxNA==,size_16,color_FFFFFF,t_70#pic_center" target="_blank" rel="noopener" data-fancybox="group" data-caption="测试用例" class="fancybox"><img alt="测试用例" title="测试用例" data-src="https://img-blog.csdnimg.cn/20200820205216510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgwNzcxNA==,size_16,color_FFFFFF,t_70#pic_center" class="lazyload"></a></p>
<h3 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h3><p>&emsp;&emsp;经过排查发现，<code>count</code>函数还是需要加上左右区间边界的，显然想利用<code>c++ STL</code>的偷懒想法破灭啦～如果没有左右边界，每次执行<code>count</code>函数都要对整个数组进行循环，这个时间复杂度肯定是无法接受的～</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)                                <span class="comment">//递归出口，区间内仅有一个元素</span></span><br><span class="line">            <span class="keyword">return</span> nums[l];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (r - l) / <span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">int</span> leftMax = helper(nums, l, mid);       <span class="comment">//左区间多数元素</span></span><br><span class="line">        <span class="keyword">int</span> rightMax = helper(nums, mid + <span class="number">1</span>, r);  <span class="comment">//右区间多数元素</span></span><br><span class="line">        <span class="keyword">if</span>(leftMax == rightMax)                   <span class="comment">//左右区间多数元素相同</span></span><br><span class="line">            <span class="keyword">return</span> leftMax;</span><br><span class="line">        <span class="comment">//左右区间多数元素不同，比较在合并区间的次数</span></span><br><span class="line">        <span class="keyword">int</span> leftCount = count(nums, leftMax, l, r);</span><br><span class="line">        <span class="keyword">int</span> rightCount = count(nums, rightMax, l, r);</span><br><span class="line">        <span class="keyword">return</span> leftCount &gt; rightCount ? leftMax : rightMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)</span><br><span class="line">                c++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><br></p>
<h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50.Pow(x,n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50.Pow(x,n)</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>&emsp;&emsp; 实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
<blockquote>
<p>示例 1:<br>输入: 2.00000, 10<br>输出: 1024.00000</p>
<p>示例 2:<br>输入: 2.10000, 3<br>输出: 9.26100</p>
<p>示例 3:<br>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25</p>
</blockquote>
<p>&emsp;&emsp; 说明:</p>
<ul>
<li>-100.0 &lt; x &lt; 100.0</li>
<li>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li>
</ul>
<h3 id="题目理解"><a href="#题目理解" class="headerlink" title="题目理解"></a>题目理解</h3><p>&emsp;&emsp; 依旧是分治，依旧是类似于二叉树的递归模型。不过，这次加上了实际应用背景（数学相关），所以要求我们将问题用分治思想抽象成递归模型。有了小数点，一切看起来都是这么凌乱～这里有三点细节需要注意：</p>
<ol>
<li>幂次<code>n</code>的奇偶性</li>
<li><code>x</code>的正负性</li>
<li><code>return</code>的类型</li>
</ol>
<p>&emsp;&emsp; 先给出两个计算过程：</p>
<script type="math/tex; mode=display">x^{64}->x^{32}->x^{16}->x^{8}->x^{4}->x^{2}->x^{1}</script><script type="math/tex; mode=display">x^{77}->x^{38}->x^{19}->x^{9}->x^{4}->x^{2}->x^{1}</script><p>&emsp;&emsp; 我们发现，这其实和之前两道题的分治法并无太大区别。依旧是<code>⌊n/2⌋</code>，依旧是将计算交给递归（其实更想树的递归）。我们要将目光集中在当前节点也就是计算这一轮结果的操作上。<br>&emsp;&emsp; 以$x^{64} &lt;- x^{32}$为例，此时<code>N == 64</code>，如何从$x^{32}$到$x^{64}$呢？不妨假设我们已经递归计算出上一轮结果$x^{32}$，也就是<code>double y = helper(x, N / 2);</code>的意思。这时候，我们只需要判断<code>N</code>的奇偶性即可。由于是偶数，所以我们只需要<code>y*y</code>即可得出这一轮结果。<br>&emsp;&emsp; 再以$x^{77}&lt;-x^{38}$为例，此时<code>N == 77</code>，如何从$x^{77}$到$x^{38}$呢？照猫画虎，已经递归计算出上一轮结果$x^{38}$。显然<code>N</code>为奇数，如果<code>y*y</code>，相当于只计算出$x^{76}$的结果，这是不够的。此时，我们只需要再乘一个<code>x</code>即可，即<code>y*y*x</code>。<strong>注意</strong>：<code>x</code>这个参数始终不变。</p>
<h3 id="题目代码-2"><a href="#题目代码-2" class="headerlink" title="题目代码"></a>题目代码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;      <span class="comment">//防止n越界</span></span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? helper(x, N) : <span class="number">1.0</span> / helper(x, -N);   <span class="comment">//幂次为负</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;                           <span class="comment">//递归出口，x^0 = 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> y = helper(x, N / <span class="number">2</span>);              <span class="comment">//上一轮结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;    <span class="comment">//奇数，多乘一个x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><br></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;其实，理解分治算法容易，灵活运用分治算法并不容易。通过这三道题，我发现本质上都是在围绕“分隔区间再合并区间”做文章，当然，目前都是以中点为分隔点。在代码构成上，类似于二叉树的遍历递归模型。实际上，我认为可以先从二叉树相关题目入手，理解递归。弄懂了递归的奥妙，再取碰这些分治法会更轻松一些。<br>&emsp;&emsp;另外，最基础的二分查找也是分治法的一种。从它入手，也可以更好地理解分治思想。以下是我写的一个简单的二分查找方法～</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(T arr[], <span class="keyword">int</span> n, T target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n; <span class="comment">//左右边界，在[l...r)的范围里寻找target</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;        <span class="comment">//当l==r时，区间[l...r)无效</span></span><br><span class="line">        <span class="comment">//int mid = (l+r) / 2;</span></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;  <span class="comment">//l，r均为int型，当l，r均很大时，l+r可能会产生整型溢出问题。c++不报错</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; arr[mid])</span><br><span class="line">            l = mid + <span class="number">1</span>;    <span class="comment">//target在[mid+1...r)中</span></span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">//target&lt;arr[mid]</span></span><br><span class="line">            r = mid;    <span class="comment">//target在[l...mid)中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>&emsp;&emsp;以上是我对于分治算法的初步认识～</p>
<p><br></p>
<blockquote>
<p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。<br>本人blog：<a href="http://breadhunter.gitee.io" target="_blank" rel="noopener">http://breadhunter.gitee.io</a></p>
</blockquote>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构    </a><a class="post-meta__tags" href="/tags/leetcode/">leetcode    </a><a class="post-meta__tags" href="/tags/%E5%88%86%E6%B2%BB%E6%B3%95/">分治法    </a><a class="post-meta__tags" href="/tags/%E9%80%92%E5%BD%92/">递归    </a></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/08/16/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><img class="next_cover lazyload" data-src="https://img-blog.csdnimg.cn/20200809164842535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTMxMzMxOQ==,size_16,color_FFFFFF,t_70" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>阅读文章——基于 CART 决策树的计算机网络课程学生成绩分析</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/08/15/347前K个高频元素/" title="347前K个高频元素"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/zhengguanyu/zhengguanyu.github.io@2.0/img/Second.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-08-15</div><div class="relatedPosts_title">347前K个高频元素</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 东北石油大学智能技术与自然语言处理实验室</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">欢迎来到我们团队的博客！</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/fireworks.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>